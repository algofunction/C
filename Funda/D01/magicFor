/*
Ecrire un programme C qui définit un nombre magique (un nombre secret), et lit des entiers à l’entrée jusqu’à ce que l’utilisateur trouve ce nombre. En lui indiquant à chaque fois s’il est en dessus ou au-dessous du nombre magique.
*/

#include<stdio.h>
#include<stdlib.h>
int main()
{
    int mag,a;
    mag=12;
    printf("Tentez votre chance:\n");
    do{
       scanf("%d",&a);
       if(a<mag) printf("Pas encore! essayez un nombre plus grand.\n");
       if(a>mag) printf("Pas encore! essayez un nombre plus petit.\n");
       if(a==mag) printf("Bravo! vous avez trouver le nombre magique.\n");
    }while(a!=mag);
    system("pause");
    return 0;
}


remove below





Enoncé exercice 2
Ecrire un programme C qui lit un entier puis détermine s’il est premier ou non.
On rappelle qu’un entier est dit premier s’il a exactement deux diviseurs différents; 1 et lui-même.
Ex: 2, 3, 7, 17, 101 sont tous premiers, et 4, 10, 27 ne le sont pas.

Correction exercice 2
Après la déclaration des variables dont on aura besoin, on passe à la lecture l’entier p sur lequel on va effectuer le test de primalité.

Dès le départ on fait un test pour voir si p est égal à 1 ou à 0, dans ces deux cas on affiche que le nombre n’est pas premier (ligne 8).

Ps (bloc else), c’est-à-dire lorsque p est supérieur ou égal à 2, on va supposer que p est premier en affectant la valeur 1 à la variable pr (ligne 11).

Ensuite on va parcourir les diviseurs possibles de p, à savoir les nombres de 2 jusqu’à p-1, à l’aide du compteur i de la boucle for. A noter que l’utilisation de la boucle for ici vient du fait qu’on connait le nombre des itérations qui est de 2 jusqu’à p-1.

En parcourant ces entiers, si on trouve un nombre i qui divise p, on va conclure que l’hypothèse de primalité présupposée est fausse et on l’indiquera en affectant 0 à la variable pr (ligne 14). On peut à ce stade arrêter la recherche à l’aide de l’instruction break qui permet, une fois exécutée, de sortir de la boucle dont elle est à l’intérieur. Il faut faire attention à ce que l’instruction break vient après l’opération d’affectation, sinon cette dernière n’aura pas lieu (ligne 14).

Une fois sorti de la boucle for, on va faire un test sur la valeur de la variable pr. Si elle est égale à 1 on affiche que le nombre entré est premier (ligne 16). Sinon, on peut déduire qu’on a trouvé un i qui divise p, du coup ce dernier n’est pas premier (ligne 17).

Dans le cas spécial où p est égal à 2, la boucle ne sera pas exécutée, puisque la condition i<p (i et p sont tous les deux égaux à 2) ne sera pas vérifiée. Donc la variable pr va garder la valeur de 1 qui est convenable puisque 2 est un nombre premier.







Solution exercice 2
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int p,i,pr;
    printf("Donnez un entier:\n");
    scanf("%d",&p);
    if(p==0 || p==1) printf("%d n'est pas premier.\n",p);
    else
    {
        pr=1;
        for(i=2;i<p;i++)
        {
            if(p%i==0) {pr=0; break; }
        }
        if(pr==1) printf("%d est premier.\n",p);
        else printf("%d n'est pas premier.\n",p);
    }
    system("pause");
    return 0;
}
Enoncé exercice 3
Ecrire un programme C qui lit une série d’entiers positifs inférieurs à 100 terminée par 0. Et qui doit négliger toute entrée strictement supérieure à 100. Puis calcule et affiche la somme et le max des éléments de cette série.

Correction exercice 3
Dans cet exercice on a opté pour la boucle while, pour la lecture des éléments de la série. Et ceci puisqu’on ne connait pas le nombre des éléments que va entrer l’utilisateur. A l’intérieur de cette boucle, on va utiliser une deuxième boucle de type do while pour pouvoir négliger les entrées supérieures à 100. Et ce, en y mettant dedans la fonction scanf et en lui précisant une condition qui permettra de réitérer chaque fois que le nombre lu est supérieur à 100 (lignes 12-15).

Puisqu’on veut calculer le max et la somme des entiers qui seront lus, on doit obligatoirement initialiser les deux variables qui vont abriter ces deux quantités à l’extérieure de la boucle while (lignes 6-7). La variable som comme d’habitude est initialisée à 0, max doit être initialisé à une valeur inférieure ou égale à la plus petite valeur possible en entrée qui est 0 dans ce cas.

Après ce qu’on sort de la boucle de lecture do while, on est alors sûr que l’entier entré est valide. On l’ajoute donc à la somme (ligne 16). Et on le compare avec le max actuel, s’il lui est supérieur il représentera dans ce cas le nouveau max, on

A l’extérieur de la boucle while on affiche la somme et le max de cette série (lignes 19-20).

La boucle va s’arrêter lorsque le nombre entré est égal à zéro puisque la condition de fonctionnement de la boucle while est telle que l’entier lu a doit être différent de 0 (ligne 10): while(a!=0) (!= veut dire différent).

L’initialisation de la variable a à 1 permet d’être sûr qu’on peut accéder à la boucle while dans sa première itération (ligne 8).

Solutiion exercice 3
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int som,max,a;
    som=0;
    max=0;
    a=1;
    printf("Entrez une serie d'entier, pour finir entrez 0.\n");
    while(a!=0)
    {
       do{
            scanf("%d",&a);
            if(a>100) printf("Entrez SVP un entier inferieur ou egal a 100\n");
       }while(a>100);
       som+=a;
       if(a>max) max=a;
    }
    printf("la somme: %d\n",som);
    printf("le max: %d\n",max);
    system("pause");
    return 0;
}
Enoncé exercice 4
Ecrire un programme C qui lit un entier et l’affiche inversé. On choisira de ne pas afficher chiffre par chiffre mais de construire l’entier inversé puis l’afficher.

Ex: si l’entrée est 12345 on doit afficher l’entier 54321.

Correction exercice 4
Encore une fois, on va exploiter dans cet exercice la notion de la division entière. On doit, pour l’entier qu’on souhaite inverser, être capable d’accéder à tous ses chiffres. Pour ainsi faire, on utilisera le modulo 10 pour récupérer le chiffre des unités (ligne 11). Et puis, la division par 10 pour se débarrasser du chiffre unité déjà utilisé (ligne 13). Et après, refaire la même chose jusqu’à épuisement de la totalité des chiffres.

Pour constituer le nombre inverse b, on l’initialise par zéro (ligne 8) et à chaque fois on le multiplie par 10 pour décaler ses chiffres à gauche et faire place au chiffre unité de a qu’on lui ajoutera (ligne 12).

Pour parcourir tous les chiffres de a, on va utiliser une boucle while qui doit s’arrêter une fois que a devient égale à zéro. Ce qui correspond au traitement du dernier chiffre de a.

La force de cette méthode vient du fait qu’on n’est pas besoin de connaître le nombre de chiffres de a pour pouvoir l’inverser. Sa seule limite est que le nombre de chiffre est limité par la taille du type int.

Solution exercice 4
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int r,a,b;
    printf("Donner un entier positif:\n");
    scanf("%d",&a);
    b=0;
    while(a>0)
    {
        r=a%10;
        b=10*b+r;
        a=a/10;
    }
    printf("l'inverse de l'entier donne en entree est %d\n",b);
    system("pause");
    return 0;
}
Enoncé exercice 5
Ecrire un programme C qui lit un entier puis affiche tous les nombres premiers qui lui sont inférieurs.

Correction exercice 5
Dans cet exercice on va procéder de la manière suivante: on parcourt avec une boucle for de compteur p, les entiers entre 2 et n, n étant le nombre entré par l’utilisateur (ligne 9). Et, à chaque fois on fait un test de primalité sur p (lignes 11-15), s’il s’avère qu’il est premier on l’affiche sur le champ.

Pour le test de primalité il est expliqué en détail dans l’exercice 2 en dessus.

Solution exercice 5
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int n,i,p,ok;
    printf("Donnez un entier:\n");
    scanf("%d",&n);
    printf("Les nombres premiers inferieurs a %d sont:\n",n);
    for(p=2;p<=n;p++)
    {
        ok=1;
        for(i=2;i<p;i++)
        {
            if(p%i==0) {ok=0; break; }
        }
        if(ok==1) printf("%d ",p);
    }
    printf("\n");
    system("pause");
    return 0;
}
Cours particuliers à distance


Pour préparer vos examens et surmonter vos difficultés en programmation..

Algorithmique, Langage C, Python et Java

..profitez des séances de soutien à distance en me contactant sur mon email.

Cours effectués avec partage d'écran via Microsoft teams, Google Meet, Skype …

Email: mohamed.tirichen@gmail.com

Mohamed TIRICHEN, Editeur du site

Tarif : 25 €/heure

ACCUEIL EBOOKS EXERCICES C PYTHON YOUTUBEHestia | Développé par ThemeIsle
⚙ Privacy
